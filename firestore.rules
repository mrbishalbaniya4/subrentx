
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model with an
 * approval system, with an exception for a designated admin user. All data is
 * sandboxed to the authenticated user, meaning a user can only ever access their
 * own information and the items they create, BUT ONLY if their account status is 'active'.
 * The admin user ('mrbishalbaniya4@gmail.com') has read and write access to all data
 * for administrative purposes, including changing a user's status.
 *
 * Data Structure: The data is organized hierarchically. A top-level 'users' collection
 * holds user profile documents which contain a 'status' field ('pending', 'active', 'suspended').
 * All other data ('items', 'activity-logs') is in subcollections under the user's document.
 * Item documents are split into a summary document and a 'details' subcollection to reduce document size.
 *
 * Key Security Decisions:
 * - Admin Role: An admin user ('mrbishalbaniya4@gmail.com') is granted read/write access
 *   across all user data, primarily to manage user statuses.
 * - User Approval System:
 *   - New users are created with a 'status' of 'pending'.
 *   - Users with 'pending' or 'suspended' status can only read their own user document. They cannot
 *     read or write any subcollection data (items, logs, etc.).
 *   - Only the admin can change a user's status.
 *   - Normal operations are only permitted for users with an 'active' status.
 * - User Enumeration Disabled for non-admins: Regular users cannot list the '/users' collection.
 * - Path-Based Security: Rules primarily rely on the document path to determine ownership.
 *
 * Denormalization for Authorization: The rules use `get()` to check the user's status from their
 * profile document (`/users/{userId}`) before allowing access to subcollections. This is a
 * necessary `get()` call to enforce the approval system. For example, to secure an item at
 * `/users/{userId}/items/{itemId}`, the rule checks both `request.auth.uid == userId` and
 * that `get(/databases/$(database)/documents/users/$(userId)).data.status == 'active'`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }
    
    function isAdmin() {
      // Use the verified email for a more reliable admin check.
      return isSignedIn() && request.auth.token.email_verified && request.auth.token.email == 'mrbishalbaniya4@gmail.com';
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isOwnerAndActive(userId) {
        let userProfile = get(/databases/$(database)/documents/users/$(userId));
        return isOwner(userId) && userProfile.data.status == 'active';
    }
    
    function isCreatingOwnPendingUser(userId) {
        return isOwner(userId) &&
               request.resource.data.id == userId &&
               request.resource.data.status == 'pending';
    }

    function isUpdatingOwnProfile(userId) {
        let isStatusUnchanged = request.resource.data.status == resource.data.status;
        let isIdUnchanged = request.resource.data.id == resource.data.id;
        return isOwner(userId) && isStatusUnchanged && isIdUnchanged;
    }

    function isAdminUpdatingProfile() {
      return isAdmin();
    }
    
    function hasValidItemData(userId) {
      // password, pin, and notes are no longer in the main item document
      let hasNoSensitiveFields = !('password' in request.resource.data) &&
                                 !('pin' in request.resource.data) &&
                                 !('notes' in request.resource.data);
      return request.resource.data.userId == userId && hasNoSensitiveFields;
    }

    function hasValidItemDetails() {
        // Only allow expected fields in details subcollection
        return request.resource.data.keys().hasOnly(['password', 'pin', 'notes']);
    }
    
    function isItemUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    function isItemCreationTimestampImmutable() {
      return request.resource.data.createdAt == resource.data.createdAt;
    }

    function hasValidLogData(userId) {
      return request.resource.data.userId == userId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isCreatingOwnPendingUser(userId) || isAdmin();
      allow update: if isUpdatingOwnProfile(userId) || isAdminUpdatingProfile();
      allow delete: if false;

      match /items/{itemId} {
        allow get, list: if isOwnerAndActive(userId) || isAdmin();
        allow create: if isOwnerAndActive(userId) && hasValidItemData(userId);
        allow update: if isOwnerAndActive(userId) && isItemUserIdImmutable() && isItemCreationTimestampImmutable();
        allow delete: if isOwnerAndActive(userId) || isAdmin();

        // Secure the details subcollection
        match /details/data {
          allow get: if isOwnerAndActive(userId) || isAdmin();
          // Allow create/update only if the user is active and the data is valid
          allow write: if isOwnerAndActive(userId) && hasValidItemDetails();
          allow delete: if isOwnerAndActive(userId) || isAdmin();
        }
      }

      match /activity-logs/{logId} {
        allow get: if isOwnerAndActive(userId) || isAdmin();
        allow list: if isOwnerAndActive(userId) || isAdmin();
        allow create: if isOwnerAndActive(userId) && hasValidLogData(userId);
        allow update: if false;
        allow delete: if false;
      }
    }
  }
}
